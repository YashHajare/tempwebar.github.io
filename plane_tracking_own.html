<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plane Tracking with Camera</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
    }
    video, canvas { 
      position: absolute; 
      top: 0; 
      left: 0; 
    }
  </style>
</head>
<body>

<!-- Video feed from the camera -->
<video id="videoInput" autoplay playsinline></video>

<!-- Canvas for edge detection (OpenCV) -->
<canvas id="canvasOutput"></canvas>

<!-- 3D Scene using Three.js -->
<div id="webgl-container"></div>

<!-- Include external libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
<script src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>

  // --- 1. Access and Display Camera Stream ---
  const video = document.getElementById('videoInput');
  const canvas = document.getElementById('canvasOutput');
  const ctx = canvas.getContext('2d');

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;
      console.log("✅ Camera started successfully");
    } catch (error) {
      console.error("❌ Error starting camera:", error);
      alert("Camera access failed: " + error.message);
    }
  }

  video.addEventListener('play', () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    console.log("✅ Video started, canvas dimensions set");

    const cap = new cv.VideoCapture(video);
    const mat = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
    const edges = new cv.Mat();
    const lines = new cv.Mat();

    function processFrame() {
      try {
        cap.read(mat);
        cv.cvtColor(mat, mat, cv.COLOR_RGBA2GRAY, 0);
        cv.Canny(mat, edges, 50, 150, 3);

        // Detect lines using Hough Line Transform
        cv.HoughLinesP(edges, lines, 1, Math.PI / 180, 50, 50, 10);

        // Draw the detected lines (for visual representation)
        for (let i = 0; i < lines.rows; i++) {
          const [x1, y1, x2, y2] = lines.data32S.slice(i * 4, i * 4 + 4);
          cv.line(mat, new cv.Point(x1, y1), new cv.Point(x2, y2), [0, 255, 0, 255], 2);
        }

        cv.imshow('canvasOutput', mat);
      } catch (error) {
        console.error("❌ Error processing frame:", error);
      }
      requestAnimationFrame(processFrame);
    }

    processFrame();
  });

  // Start the camera
  startCamera();

  // --- 2. Create Three.js Scene for 3D Overlay ---
  const container = document.getElementById('webgl-container');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  container.appendChild(renderer.domElement);

  // Add a light source
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(0, 1, 1).normalize();
  scene.add(directionalLight);

  // --- 3. Add 3D Plane to the Scene ---
  const geometry = new THREE.PlaneGeometry(1, 1);
  const material = new THREE.MeshBasicMaterial({ color: 0xff5733, side: THREE.DoubleSide });
  const plane = new THREE.Mesh(geometry, material);
  scene.add(plane);

  // Position the 3D plane at the center of the scene
  plane.position.set(0, 0, -2);

  // Add rotation for visual effect
  function animate() {
    requestAnimationFrame(animate);
    plane.rotation.x += 0.01; // Rotate the plane on the X-axis
    plane.rotation.y += 0.01; // Rotate the plane on the Y-axis
    renderer.render(scene, camera);
  }
  animate();

  // Adjust the camera and scene on window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>

</body>
</html>
